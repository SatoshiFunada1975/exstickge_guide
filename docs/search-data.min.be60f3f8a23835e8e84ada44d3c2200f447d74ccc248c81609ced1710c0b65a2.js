'use strict';(function(){const indexCfg=;indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/exstickge_guide/docs/about/board_overview/','title':"ボード概要",'content':"ボード概要 exStickGE - UDP/IPを手軽に利用できるFPGAボード exStickGEは，Artix-7を搭載したギガビットイーサネットポートを持つFPGAボードです．同梱のe7UDP/IP IPコアを使うことで，簡単にネットワーク接続アプリケーション実装できます．拡張コネクタで約80ポートのI/Oを利用できます．標準構成では，HDMIおよびMIPI-CSIポートを搭載したビジョンボードとの組合せで提供されます．\n メイン基板 メイン基板は，FPGAとイーサネットポートを搭載するシンプルな構成です．LEDやスイッチ，PMODポートを搭載しています．DC 5Vを供給して利用します．\n FPGAの裏には，256MBのDDRメモリと拡張コネクタを搭載しています．\n メイン基板搭載部品    　 型番・パラメタ     FPGA XC7A200TSBG484-2   コンフィグROM MT25QL128ABA1ESE-0SIT   ユーザクロック 200MHz   DDRメモリ MT41K128M16JT-125   Ethernet PHY RTL8211E-VB   電源コネタク DF1B-2P-2.5DS(1ピン: 5V, 2ピン: GND)   拡張コネクタ DF40C-100DP-0.4V    ビジョン基板 ビジョン基板は拡張コネクタの先に接続できる画像処理アプリケーション実装向けのボードです．HDMIポートとMIPI CSI-2をそれぞれ2ポートずつ搭載します．また2.54mmピッチ40ピンコネタクを介して，26ポートのGPIOを利用できます．\n 参考リンク 製品の詳細は，e-trees.Japanの製品ページ101「exStickGE」もご覧ください．また，製品についての問い合わせは，e-trees.Japanの問い合わせフォームよりご連絡ください．\n"});index.add({'id':1,'href':'/exstickge_guide/docs/setup/installation/','title':"インストール",'content':"インストール 電源の接続 exStickGEを利用するためには，CN4から5Vの電源を投入する必要があります．CN4のピン配置は次の通りです．\n 附属の電源ケーブルを利用する場合は，\n   項目 スペック     外径 5.5mm   内径 2.1mm   極性 センタープラス   出力電圧 5V   出力電流 2A以上を推奨    に適合したACアダプタを利用してください．\nJTAGアダプタ FPGAのコンフィギュレーションおよびROMへの書き込み時は，CN5にXilinxの書き込みアダプタを接続してください．ピン穴が千鳥になっているため半田付けしなくともピンヘッダを挿入するだけで書き込みができます．\nピン配置は次の通りです．Digilent社のJTAG-HS2プログラミングケーブルを直接利用できます．\n 開発ソフトウェア FPGAの開発にはVivadoを利用してください．搭載しているFPGA XC7A200TSBG484-2は無償で利用可能なWebPackで開発できます．\nボード定義ファイル exStickGEのボード定義ファイルを https://github.com/e-trees/board_files からダウンロードして利用できます．利用する場合は，以下のように，ダウンロードしたファイルを解凍しVivadoのボードファイルディレクトリの下にコピーしてください．\n$ wget https://github.com/e-trees/board_files/archive/master.zip $ unzip master.zip $ sudo mv board_files-master/board_files/exstickge /tools/Xilinx/Vivado/2020.1/data/boards/board_files/ 制約ファイルのサンプル 以下はVivado用の制約ファイル(XDCファイル)の例です．拡張コネタクタにビジョン基板を接続していることを想定しています．\n# # Main board # # SYSY CLK 200MHz set_property -dict {PACKAGE_PIN H4 IOSTANDARD LVDS_25} [get_ports SYS_CLK_P] set_property -dict {PACKAGE_PIN G4 IOSTANDARD LVDS_25} [get_ports SYS_CLK_N] create_clock -period 5.000 -name clk_pin -waveform {0.000 2.500} -add [get_ports SYS_CLK_P] # ON BOARD LEDs set_property -dict {PACKAGE_PIN E21 IOSTANDARD LVCMOS33} [get_ports {LED[0]}] set_property -dict {PACKAGE_PIN D21 IOSTANDARD LVCMOS33} [get_ports {LED[1]}] set_property -dict {PACKAGE_PIN G22 IOSTANDARD LVCMOS33} [get_ports {LED[2]}] # PUSH BUBTTON set_property -dict {PACKAGE_PIN D19 IOSTANDARD LVCMOS33} [get_ports PUSH_BTN] # PMOD set_property {PACKAGE_PIN R18 IOSTANDARD LVCMOS33} [get_ports {PMOD[1]}] set_property {PACKAGE_PIN T18 IOSTANDARD LVCMOS33} [get_ports {PMOD[2]}] set_property {PACKAGE_PIN N17 IOSTANDARD LVCMOS33} [get_ports {PMOD[3]}] set_property {PACKAGE_PIN P17 IOSTANDARD LVCMOS33} [get_ports {PMOD[4]}] # Ethernet set_property -dict {PACKAGE_PIN AA14 IOSTANDARD LVCMOS33} [get_ports {GEPHY_RD[3]}] set_property -dict {PACKAGE_PIN Y13 IOSTANDARD LVCMOS33} [get_ports {GEPHY_RD[2]}] set_property -dict {PACKAGE_PIN AB15 IOSTANDARD LVCMOS33} [get_ports {GEPHY_RD[1]}] set_property -dict {PACKAGE_PIN AA15 IOSTANDARD LVCMOS33} [get_ports {GEPHY_RD[0]}] set_property -dict {PACKAGE_PIN AB17 IOSTANDARD LVCMOS33} [get_ports {GEPHY_TD[3]}] set_property -dict {PACKAGE_PIN AB16 IOSTANDARD LVCMOS33} [get_ports {GEPHY_TD[2]}] set_property -dict {PACKAGE_PIN AA16 IOSTANDARD LVCMOS33} [get_ports {GEPHY_TD[1]}] set_property -dict {PACKAGE_PIN Y16 IOSTANDARD LVCMOS33} [get_ports {GEPHY_TD[0]}] set_property -dict {PACKAGE_PIN T16 IOSTANDARD LVCMOS33} [get_ports GEPHY_PMEB] set_property -dict {PACKAGE_PIN Y11 IOSTANDARD LVCMOS33} [get_ports GEPHY_RCK] set_property -dict {PACKAGE_PIN U16 IOSTANDARD LVCMOS33} [get_ports GEPHY_RST_N] set_property -dict {PACKAGE_PIN AA9 IOSTANDARD LVCMOS33} [get_ports GEPHY_RXDV_ER] set_property -dict {PACKAGE_PIN AB13 IOSTANDARD LVCMOS33} [get_ports GEPHY_TCK] set_property -dict {PACKAGE_PIN AA13 IOSTANDARD LVCMOS33} [get_ports GEPHY_TXEN_ER] set_property -dict {PACKAGE_PIN AA11 IOSTANDARD LVCMOS33} [get_ports GEPHY_INT_N] set_property -dict {PACKAGE_PIN AA10 IOSTANDARD LVCMOS33} [get_ports GEPHY_MDC] set_property -dict {PACKAGE_PIN AB10 IOSTANDARD LVCMOS33} [get_ports GEPHY_MDIO] create_clock -period 8.000 -name rgmii_rxclk -waveform {0.000 4.000} [get_ports GEPHY_RCK] # DRAM set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN U5} [get_ports {ddr3_addr[0]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN T5} [get_ports {ddr3_addr[1]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN W4} [get_ports {ddr3_addr[2]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN V4} [get_ports {ddr3_addr[3]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN AA4} [get_ports {ddr3_addr[4]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN Y4} [get_ports {ddr3_addr[5]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN AB5} [get_ports {ddr3_addr[6]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN AA5} [get_ports {ddr3_addr[7]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN AA3} [get_ports {ddr3_addr[8]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN Y3} [get_ports {ddr3_addr[9]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN AB2} [get_ports {ddr3_addr[10]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN AB3} [get_ports {ddr3_addr[11]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN AB1} [get_ports {ddr3_addr[12]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN AA1} [get_ports {ddr3_addr[13]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN U6} [get_ports {ddr3_ba[0]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN W5} [get_ports {ddr3_ba[1]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN W6} [get_ports {ddr3_ba[2]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN U1} [get_ports {ddr3_dq[0]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN U2} [get_ports {ddr3_dq[1]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN V2} [get_ports {ddr3_dq[2]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN W2} [get_ports {ddr3_dq[3]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN Y2} [get_ports {ddr3_dq[4]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN W1} [get_ports {ddr3_dq[5]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN Y1} [get_ports {ddr3_dq[6]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN U3} [get_ports {ddr3_dq[7]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN AA6} [get_ports {ddr3_cke[0]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN Y6} [get_ports {ddr3_cs_n[0]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN T6} [get_ports ddr3_we_n] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN R6} [get_ports ddr3_cas_n] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN T1} [get_ports {ddr3_dm[0]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN V7} [get_ports {ddr3_odt[0]}] set_property -dict {IOSTANDARD SSTL15 PACKAGE_PIN V5} [get_ports ddr3_ras_n] set_property -dict {IOSTANDARD DIFF_SSTL15 PACKAGE_PIN V8} [get_ports {ddr3_ck_n[0]}] set_property -dict {IOSTANDARD DIFF_SSTL15 PACKAGE_PIN V9} [get_ports {ddr3_ck_p[0]}] set_property -dict {IOSTANDARD DIFF_SSTL15 PACKAGE_PIN R2} [get_ports {ddr3_dqs_n[0]}] set_property -dict {IOSTANDARD DIFF_SSTL15 PACKAGE_PIN R3} [get_ports {ddr3_dqs_p[0]}] set_property -dict {IOSTANDARD LVCMOS15 PACKAGE_PIN R4} [get_ports ddr3_reset_n] # # Vision board # # HDMI CN2 set_property -dict {PACKAGE_PIN V20 IOSTANDARD TMDS_33} [get_ports TMDS_CN2_Clk_n] set_property -dict {PACKAGE_PIN U20 IOSTANDARD TMDS_33} [get_ports TMDS_CN2_Clk_p] set_property -dict {PACKAGE_PIN V22 IOSTANDARD TMDS_33} [get_ports {TMDS_CN2_Data_n[0]}] set_property -dict {PACKAGE_PIN U22 IOSTANDARD TMDS_33} [get_ports {TMDS_CN2_Data_p[0]}] set_property -dict {PACKAGE_PIN U21 IOSTANDARD TMDS_33} [get_ports {TMDS_CN2_Data_n[1]}] set_property -dict {PACKAGE_PIN T21 IOSTANDARD TMDS_33} [get_ports {TMDS_CN2_Data_p[1]}] set_property -dict {PACKAGE_PIN R19 IOSTANDARD TMDS_33} [get_ports {TMDS_CN2_Data_n[2]}] set_property -dict {PACKAGE_PIN P19 IOSTANDARD TMDS_33} [get_ports {TMDS_CN2_Data_p[2]}] set_property -dict {PACKAGE_PIN W21 IOSTANDARD LVCMOS33} [get_ports TMDS_CN2_SCL] set_property -dict {PACKAGE_PIN W22 IOSTANDARD LVCMOS33} [get_ports TMDS_CN2_SDA] set_property -dict {PACKAGE_PIN A21 IOSTANDARD LVCMOS33} [get_ports TMDS_CN2_OUT_EN] set_property -dict {PACKAGE_PIN B21 IOSTANDARD LVCMOS33 PULLUP true} [get_ports TMDS_CN2_HPD] # HDMI CN3 set_property -dict {PACKAGE_PIN W20 IOSTANDARD TMDS_33} [get_ports TMDS_CN3_Clk_n] set_property -dict {PACKAGE_PIN W19 IOSTANDARD TMDS_33} [get_ports TMDS_CN3_Clk_p] set_property -dict {PACKAGE_PIN Y19 IOSTANDARD TMDS_33} [get_ports {TMDS_CN3_Data_n[0]}] set_property -dict {PACKAGE_PIN Y18 IOSTANDARD TMDS_33} [get_ports {TMDS_CN3_Data_p[0]}] set_property -dict {PACKAGE_PIN V19 IOSTANDARD TMDS_33} [get_ports {TMDS_CN3_Data_n[1]}] set_property -dict {PACKAGE_PIN V18 IOSTANDARD TMDS_33} [get_ports {TMDS_CN3_Data_p[1]}] set_property -dict {PACKAGE_PIN AB20 IOSTANDARD TMDS_33} [get_ports {TMDS_CN3_Data_n[2]}] set_property -dict {PACKAGE_PIN AA19 IOSTANDARD TMDS_33} [get_ports {TMDS_CN3_Data_p[2]}] set_property -dict {PACKAGE_PIN AA20 IOSTANDARD LVCMOS33} [get_ports TMDS_CN3_SCL] set_property -dict {PACKAGE_PIN AA21 IOSTANDARD LVCMOS33} [get_ports TMDS_CN3_SDA] set_property -dict {PACKAGE_PIN D22 IOSTANDARD LVCMOS33} [get_ports TMDS_CN3_OUT_EN] set_property -dict {PACKAGE_PIN E22 IOSTANDARD LVCMOS33 PULLUP true} [get_ports TMDS_CN3_HPD] # GPIO set_property -dict {PACKAGE_PIN C14 IOSTANDARD LVCMOS33} [get_ports GPIO00] set_property -dict {PACKAGE_PIN C15 IOSTANDARD LVCMOS33} [get_ports GPIO01] set_property -dict {PACKAGE_PIN D14 IOSTANDARD LVCMOS33} [get_ports GPIO02] set_property -dict {PACKAGE_PIN D15 IOSTANDARD LVCMOS33} [get_ports GPIO03] set_property -dict {PACKAGE_PIN B15 IOSTANDARD LVCMOS33} [get_ports GPIO04] set_property -dict {PACKAGE_PIN B16 IOSTANDARD LVCMOS33} [get_ports GPIO05] set_property -dict {PACKAGE_PIN C13 IOSTANDARD LVCMOS33} [get_ports GPIO06] set_property -dict {PACKAGE_PIN B13 IOSTANDARD LVCMOS33} [get_ports GPIO07] set_property -dict {PACKAGE_PIN A15 IOSTANDARD LVCMOS33} [get_ports GPIO10] set_property -dict {PACKAGE_PIN A16 IOSTANDARD LVCMOS33} [get_ports GPIO11] set_property -dict {PACKAGE_PIN A13 IOSTANDARD LVCMOS33} [get_ports GPIO12] set_property -dict {PACKAGE_PIN A14 IOSTANDARD LVCMOS33} [get_ports GPIO13] set_property -dict {PACKAGE_PIN B17 IOSTANDARD LVCMOS33} [get_ports GPIO14] set_property -dict {PACKAGE_PIN B18 IOSTANDARD LVCMOS33} [get_ports GPIO15] set_property -dict {PACKAGE_PIN C18 IOSTANDARD LVCMOS33} [get_ports GPIO20] set_property -dict {PACKAGE_PIN C19 IOSTANDARD LVCMOS33} [get_ports GPIO21] set_property -dict {PACKAGE_PIN B20 IOSTANDARD LVCMOS33} [get_ports GPIO22] set_property -dict {PACKAGE_PIN A20 IOSTANDARD LVCMOS33} [get_ports GPIO23] set_property -dict {PACKAGE_PIN A18 IOSTANDARD LVCMOS33} [get_ports GPIO24] set_property -dict {PACKAGE_PIN A19 IOSTANDARD LVCMOS33} [get_ports GPIO25] set_property -dict {PACKAGE_PIN D20 IOSTANDARD LVCMOS33} [get_ports GPIO26] set_property -dict {PACKAGE_PIN C20 IOSTANDARD LVCMOS33} [get_ports GPIO27] set_property -dict {PACKAGE_PIN C22 IOSTANDARD LVCMOS33} [get_ports GPIO30] set_property -dict {PACKAGE_PIN B22 IOSTANDARD LVCMOS33} [get_ports GPIO31] set_property -dict {PACKAGE_PIN G17 IOSTANDARD LVCMOS33} [get_ports GPIO40] set_property -dict {PACKAGE_PIN G18 IOSTANDARD LVCMOS33} [get_ports GPIO41] set_property -dict {PACKAGE_PIN H17 IOSTANDARD LVCMOS33} [get_ports GPIO42] set_property -dict {PACKAGE_PIN H18 IOSTANDARD LVCMOS33} [get_ports GPIO43] set_property -dict {PACKAGE_PIN J22 IOSTANDARD LVCMOS33} [get_ports GPIO44] set_property -dict {PACKAGE_PIN H22 IOSTANDARD LVCMOS33} [get_ports GPIO45] set_property -dict {PACKAGE_PIN H20 IOSTANDARD LVCMOS33} [get_ports GPIO46] set_property -dict {PACKAGE_PIN G20 IOSTANDARD LVCMOS33} [get_ports GPIO47] set_property -dict {PACKAGE_PIN K21 IOSTANDARD LVCMOS33} [get_ports GPIO50] set_property -dict {PACKAGE_PIN K22 IOSTANDARD LVCMOS33} [get_ports GPIO51] set_property -dict {PACKAGE_PIN M21 IOSTANDARD LVCMOS33} [get_ports GPIO52] set_property -dict {PACKAGE_PIN L21 IOSTANDARD LVCMOS33} [get_ports GPIO53] set_property -dict {PACKAGE_PIN J20 IOSTANDARD LVCMOS33} [get_ports GPIO54] set_property -dict {PACKAGE_PIN J21 IOSTANDARD LVCMOS33} [get_ports GPIO55] set_property -dict {PACKAGE_PIN K18 IOSTANDARD LVCMOS33} [get_ports GPIO60] set_property -dict {PACKAGE_PIN K19 IOSTANDARD LVCMOS33} [get_ports GPIO61] set_property -dict {PACKAGE_PIN L19 IOSTANDARD LVCMOS33} [get_ports GPIO62] set_property -dict {PACKAGE_PIN L20 IOSTANDARD LVCMOS33} [get_ports GPIO63] set_property -dict {PACKAGE_PIN N22 IOSTANDARD LVCMOS33} [get_ports GPIO64] set_property -dict {PACKAGE_PIN M22 IOSTANDARD LVCMOS33} [get_ports GPIO65] set_property -dict {PACKAGE_PIN M18 IOSTANDARD LVCMOS33} [get_ports GPIO66] set_property -dict {PACKAGE_PIN L18 IOSTANDARD LVCMOS33} [get_ports GPIO67] set_property -dict {PACKAGE_PIN N18 IOSTANDARD LVCMOS33} [get_ports GPIO70] set_property -dict {PACKAGE_PIN N19 IOSTANDARD LVCMOS33} [get_ports GPIO71] set_property -dict {PACKAGE_PIN N20 IOSTANDARD LVCMOS33} [get_ports GPIO72] set_property -dict {PACKAGE_PIN M20 IOSTANDARD LVCMOS33} [get_ports GPIO73] set_property -dict {PACKAGE_PIN K17 IOSTANDARD LVCMOS33} [get_ports GPIO74] set_property -dict {PACKAGE_PIN J17 IOSTANDARD LVCMOS33} [get_ports GPIO75] set_property BITSTREAM.CONFIG.CONFIGRATE 33 [current_design] set_property BITSTREAM.CONFIG.SPI_BUSWIDTH 4 [current_design] set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design] "});index.add({'id':2,'href':'/exstickge_guide/docs/setup/blink_led/','title':"exStickGEでLチカ",'content':"exStickGEでLチカ ボードの動作確認のために，exStickGEのLEDをチカチカさせてみましょう．ここでは，サンプルコードをVivadoを使って合成してFPGA用のビットファイルを作成，exStickGEで動かしてみるまでの手順を紹介します．\nソースコード exStickGEのメインボードに搭載されている3つのLEDを順に点灯させる次のようなモジュールでLチカしてみましょう．これを blinkled.v という名前で保存します．\n`default_nettype none module blinkled ( input wire SYS_CLK_P, input wire SYS_CLK_N, input wire PUSH_BTN, output wire [2:0] LED ); reg[31:0] counter; wire SYS_CLK; IBUFDS SYS_CLK_BUF(.I(SYS_CLK_P),.IB(SYS_CLK_N),.O(SYS_CLK)); assign LED = counter[26:25] == 2\u0026#39;b01 ? 3\u0026#39;b001 : counter[26:25] == 2\u0026#39;b10 ? 3\u0026#39;b010 : counter[26:25] == 2\u0026#39;b11 ? 3\u0026#39;b100 : 3\u0026#39;b000; always @(posedge SYS_CLK) begin if(PUSH_BTN == 1\u0026#39;b0) begin counter \u0026lt;= 32\u0026#39;d0; end else begin counter \u0026lt;= counter + 32\u0026#39;d1; end end endmodule `default_nettype wire また，ピン配置の制約を以下のように与えます．こちらはexstickge.xdcという名前で保存しておきます．\n# SYSY CLK 200MHz set_property -dict {PACKAGE_PIN H4 IOSTANDARD LVDS_25} [get_ports SYS_CLK_P] set_property -dict {PACKAGE_PIN G4 IOSTANDARD LVDS_25} [get_ports SYS_CLK_N] create_clock -period 5.000 -name clk_pin -waveform {0.000 2.500} -add [get_ports SYS_CLK_P] # ON BOARD LEDs set_property -dict {PACKAGE_PIN E21 IOSTANDARD LVCMOS33} [get_ports {LED[0]}] set_property -dict {PACKAGE_PIN D21 IOSTANDARD LVCMOS33} [get_ports {LED[1]}] set_property -dict {PACKAGE_PIN G22 IOSTANDARD LVCMOS33} [get_ports {LED[2]}] # PUSH BUBTTON set_property -dict {PACKAGE_PIN D19 IOSTANDARD LVCMOS33} [get_ports PUSH_BTN] Vivadoでプロジェクトを作成 exStickGE向けのビットファイルを作成するためにVivadoのプロジェクトを作成します． Vivadoを起動して Create Project をクリックしてウィザードを開きます．  プロジェクト作成のウィザードが開きました．Nextで次にすすみます．  プロジェクト名と保存先のディレクトリを指定します．ここではexstickge_blinkledという名前をつけています．  プロジェクトのタイプはデフォルトの RTL Project のまますすみます．  プロジェクトに追加するソースコードファイルを選択できます．ここではスキップして，そのまま Next をクリックします．  プロジェクトに追加する制約ファイルを選択できます．ここではスキップして，そのまま Next をクリックします．  Default Partで，利用するFPGAを選択します．exStickGE用のボードファイルをインストールしていれば，Boardsタブから，exStickGEを選択できます．  exStickGE用のボードファイルをインストールしていない場合はPartsタブでxc7a200tsbg484-2を選びます．  プロジェクト作成ウィザードのサマリです．プロジェクト名，保存先ディレクトリ，正しくFPGAが選択できているかを確認してDoneをクリックします．  ファイルの追加 プロジェクトの作成が終わったところです． ウィンドウ左のFlow NavigatorペインにあるAdd Sourcesをクリックしてファイルを追加します．  まずは，ソースコードファイルを追加したいので，Add or create design sourcesを選択してNextをクリックします．  ファイル追加ダイアログが開くので，Add Filesをクリックします．  追加するファイルをファイル選択ダイアログで選びます．冒頭で紹介したblink_led.vファイルを選択してOKをクリックします．  ファイルをプロジェクトに追加する準備ができました．Finishをクリックしてウィザードを終了します．  プロジェクトにソースコードファイルが登録されました．制約ファイルを追加するために，もう一度，Add Sourcesをクリックしてファイルを追加するウィザードを開きます．  今度は，制約ファイルを追加するために，Add or create constraintsを選択してNextをクリックします．  ファイル追加ダイアログが開くので，Add Filesをクリックします．  追加するファイルをファイル選択ダイアログで選びます．冒頭で紹介したexstickge.xdcファイルを選択してOKをクリックします．  ファイルをプロジェクトに追加する準備ができました．Finishをクリックしてウィザードを終了します．  合成 合成するには，ウィンドウ左のFlow NavigatorペインにあるGenerate Bitstreamをクリックします．これで，ソースコードからFPGAのビットストリームを生成するのに必要な，SynthesisとImplementationが順に実行されます．  無事に合成が完了すると，Bitstream Generation Completedダイアログがあらわれます．Open Hardware Managerを選択してOKをクリックしましょう．  もし，下のようなエラーダイアログが表示されてしまったら，ここまでの手順を再度確認してください．  なお，生成されたビットファイルは，\u0026lt;プロジェクトディレクトリ\u0026gt;/\u0026lt;プロジェクト\u0026gt;.runs/impl_1/blinkled.bitです．\nFPGAに書き込む パソコンとFPGAをJTAGケーブルで接続し，電源を供給します．  Bitstream Generation CompletedダイアログでOpen Hardware Managerを選択するか，Flow NavigatorでOpen Hardware Managerをクリックしてハードウェアマネージャを開きます．ハードウェアマネージャの上，緑のバーのOpen targetをクリックし，Auto ConnectをクリックしてFPGAとの接続を確立しましょう．  正しく接続できていれば，FPGAが認識されます．  FPGAにマウスカーソルを合わせ右クリックしてコンテクストメニューを開き，Program Device...を選択します．  生成されたビットストリームファイルblinkled.bitを選択してProgramをクリックします．書き込みが完了するとボード上の3つのLEDが順々に点滅する様子が確認できます．  "});index.add({'id':3,'href':'/exstickge_guide/docs/setup/build_examples/','title':"サンプルのビルドと実行",'content':"サンプルのビルドと実行 exStickGEのサンプルはGitHubのe-trees/exstickge_samplesリポジトリで公開されています．各サンプルのビルドは次の通りです．なお，サンプルは，Vivado 2019.1でビルドすることが想定されています．\n リポジトリをクローンする IPコアをedifディレクトリ下にコピー ビルドしたいプロジェクトをスクリプトでビルド 生成したビットファイルをFPGAに書き込み 操作  以下，それぞれの手順の詳細を説明します．\nリポジトリのクローン リポジトリを手元にダウンロードしてください．\nCUIで，以下のコマンドを実行するか，\n$ git clone https://github.com/e-trees/exstickge_samples.git または，GUIのGitクライアントで https://github.com/e-trees/exstickge_samples.git をクローンしてください．\nIPコアの配置 IPコアは，リポジトリにアップロードされていません．exStickGEを購入した時のガイドに従って，e7udpip_rgmii_artix7.edifを入手し，exsticge_samples/edif の下にコピーしてください．\nなお，対応するedifのmd5値は，e7udpip_rgmii_artix7.edif.md5 の通りです．ビルドや動作がうまくいかない場合には，手元のIPコアのmd5値のご確認の上，お問い合わせよりご連絡ください．\nビルド 各サンプルは，それぞれのビルドスクリプト create_project.tcl でビルドできます．たとえば，受信パケットを折り返して送信するプロジェクト exStickGE_udpip_loopback をビルドする手順は次の通りです．\nLinuxの場合 $ source /tools/Xilinx/Vivado/2019.1/settings64.sh $ cd exstickge_samples/exStickGE_udpip_loopback $ vivado -mode batch -source ./create_project.tcl Windowsの場合 スタートメニューから，VivadoのDOSプロントを開き，\n$ cd exstickge_samples\\exStickGE_udpip_loopback $ vivado -mode batch -source create_project.tcl ビルド結果の確認 ビルド結果は，ログファイルで確認できるほか，生成されるプロジェクトファイル(prj/*.xpr)をVivadoで開いて確認することができます．\nビットファイルの書き込み ビットファイルは，prj/*.runs/impl_1/の下に作成されます．exStickGE_udpip_loopback であれば，prj/exstickge_udpip_loopback.runs/impl_1/top.bitです．VivadoのHardware ManagerでFPGAに書き込んでください．\n操作 サンプルの多くはPCとネットワーク接続してアクセスできます．たとえば，exStickGE_udpip_loopbackに対しては，次のようなRubyスクリプトでexStickGEに対してパケットの送受信ができます．\n#!/usr/bin/ruby # exStickGEにパケットを送信する require \u0026#34;socket\u0026#34; socket = UDPSocket.open() sockaddr = Socket.pack_sockaddr_in(0x4000, \u0026#34;10.0.0.3\u0026#34;) socket.send(\u0026#34;Hello World\u0026#34;, 0, sockaddr) socket.close #!/usr/bin/ruby # exStickGEからパケットを受信する require \u0026#34;socket\u0026#34; socket = UDPSocket.open() socket.bind(\u0026#34;0.0.0.0\u0026#34;, 0x4000) p socket.recv(65535) socket.close いくつかのサンプルは，node.jsとElectronを使って動作を確認できます．\n"});index.add({'id':4,'href':'/exstickge_guide/docs/udpip/udpip_overview/','title':"UDP/IP IPコア概要",'content':"UDP/IP IPコア概要 UDP/IP IPコアはユーザロジックで簡単にUDP/IPパケットを送受信できるe-trees製のIPコアです．コアとユーザロジックは，e-treesでUPLと呼んでいる制御機構付きFIFOのようなインターフェースでデータをやりとりします．コアの詳細は，e7UDP/IP商品ページをご覧ください．\nUPLフォーマット e-treesでは，ハードウェアを構成するモジュール群の物理的な接続を\n Reqeust，Ack，Enableの3つの制御信号 Strobe信号(オプション) データバス(8, 32, 64bitなど．データをシリアライズ化して転送)  に限定したUPLと呼ぶインターフェースをIPコアの標準インターフェースに採用しています． UPLを使ってモジュール同士のデータ授受をシリアライズ化したパケットとしてやり取りすることで，モジュール間接続が簡単になります．UPLの詳細は，UPLとはをご覧ください．\n受信パケットフォーマット IPコアは，受信したUDP/IPパケットを次のフォーマットでUPLに出力します．\n   # 内容     0 送信先IPアドレス(exStickGEのIPアドレス)   1 送信元IPアドレス   2 送信先ポート番号, 送信元ポート番号   3 データバイト数   4〜 データ    送信パケットフォーマット IPコアをからUDP/IPパケットを送信するには，次のフォーマットでUPLにデータを供給します．\n   # 内容     0 送信送り元IPアドレス(exStickGEのIPアドレス)   1 送信先IPアドレス   2 送信元ポート番号，送信先ポート番号,   3 データバイト数   4〜 データ    実際のデータ例 次のスクリーンショットは，IPコアが受信したパケットがUPLから出力されている様子をキャプチャしたものです(クリックで拡大)．\n  10.0.0.1(0a000001)の0xc10c番ポートから10.0.0.3(0a000001)の0x4000番ポートに対して，11バイト(0x0000000b)のデータが送られています．データが有効な期間はEnableが'1'にアサートされ続けています．\nIPコア 入出力I/F クロック・リセット MACアクセス用のクロック(125MHz)と，ユーザロジック用のクロックを供給します．\n   ポート名 幅 方向 説明     GEPHY_MAC_CLK 1 入力 MAC用入力クロック(125MHz)   GEPHY_MAC_CLK90 1 入力 90度シフトしたMAC用入力クロック(125MHz)   Reset_n 1 入力 コアのリセット(非同期・負論理)   pUPLGlobalClk 1 入力 ユーザロジックのクロック    MAC入出力 MACに接続するポートです．FPGAのI/Oに接続します．\n   ポート名 幅 方向 説明     GEPHY_RST_N 1 出力 コアへのリセット出力   GEPHY_TD 4 出力 MACへのデータ出力   GEPHY_TXEN_ER 1 出力    GEPHY_TCK 1 出力 出力クロック   GEPHY_RD 4 入力 MACからのデータ入力   GEPHY_RCK 1 入力 入力クロック   GEPHY_RXDV_ER 1 入力    GEPHY_MDC 1 出力 MIO クロック   GEPHY_MDIO 1 入出力 MIO データ   GEPHY_INT_N 1 入力     ユーザロジック入出力 ユーザロジックからUDPパケットを送信する，到着したUDPパケットをユーザロジックで受け取るためのUPLポートです．MIIデータもUPLでやりとりします．\nユーザロジック → UDP/IP IPコア (パケット送信)    ポート名 幅 方向 説明     pUdp0Send_Data 32 入力 UDPパケット送信データの入力データ(ポート0)   pUdp0Send_Request 1 入力 UDPパケット送信データの入力制御信号(ポート0)   pUdp0Send_Ack 1 出力 UDPパケット送信データの入力制御信号(ポート0)   pUdp0Send_Enable 1 入力 UDPパケット送信データの入力制御信号(ポート0)   pUdp1Send_Data 32 入力 UDPパケット送信データの入力データ(ポート1)   pUdp1Send_Request 1 入力 UDPパケット送信データの入力制御信号(ポート1)   pUdp1Send_Ack 1 出力 UDPパケット送信データの入力制御信号(ポート1)   pUdp1Send_Enable 1 入力 UDPパケット送信データの入力制御信号(ポート1)    UDP/IP IPコア → ユーザロジック (パケット受信)    ポート名 幅 方向 説明     pUdp0Receive_Data 32 出力 UDPパケット受信データの出力データ(ポート0)   pUdp0Receive_Request 1 出力 UDPパケット受信データの出力制御信号(ポート0)   pUdp0Receive_Ack 1 入力 UDPパケット受信データの出力制御信号(ポート0)   pUdp0Receive_Enable 1 出力 UDPパケット受信データの出力制御信号(ポート0)   pUdp1Receive_Data 32 出力 UDPパケット受信データの出力データ(ポート0)   pUdp1Receive_Request 1 出力 UDPパケット受信データの出力制御信号(ポート0)   pUdp1Receive_Ack 1 入力 UDPパケット受信データの出力制御信号(ポート0)   pUdp1Receive_Enable 1 出力 UDPパケット受信データの出力制御信号(ポート0)    MIIインターフェース    ポート名 幅 方向 説明     pMIIInput_Data 32 入力    pMIIInput_Request 1 入力    pMIIInput_Ack 1 出力    pMIIInput_Enable 1 入力    pMIIOutput_Data 32 出力    pMIIOutput_Request 1 出力    pMIIOutput_Ack 1 入力    pMIIOutput_Enable 1 出力     設定用パラレルポート IPアドレス，MACアドレス，UDP送受信ポート番号などはパラレルポートでコアに設定します．\n   ポート名 幅 方向 説明     pMyIpAddr 32 入力 IPアドレス   pMyMacAddr 48 入力 MACアドレス   pMyNetmask 32 入力 ネットマスク   pDefaultGateway 32 入力 デフォルトゲートウェア   pTargetIPAddr 32 入力 -   pMyUdpPort0 16 入力 ポート0のポート番号   pMyUdpPort1 16 入力 ポート1のポート番号   pPHYAddr 5 入力 PHYのアドレス   pPHYMode 4 入力 PHYのモード(4\u0026rsquo;b1000)でGbEに設定   pConfig_Core 32 入力     モニタリング信号 コアの動作をモニタリングするためのステータスがパラレルポートを出力します．特にモニタリングする必要がなければオープンにしてください．\n   ポート名 幅 方向 説明     pStatus_RxByteCount 32 出力    pStatus_RxPacketCount 32 出力    pStatus_RxErrorPacketCount 16 出力    pStatus_RxDropPacketCount 16 出力    pStatus_RxARPRequestPacketCount 16 出力    pStatus_RxARPReplyPacketCount 16 出力    pStatus_RxICMPPacketCount 16 出力    pStatus_RxUDP0PacketCount 16 出力    pStatus_RxUDP1PacketCount 16 出力    pStatus_RxIPErrorPacketCount 16 出力    pStatus_RxUDPErrorPacketCount 16 出力    pStatus_TxByteCount 32 出力    pStatus_TxPacketCount 32 出力    pStatus_TxARPRequestPacketCount 16 出力    pStatus_TxARPReplyPacketCount 16 出力    pStatus_TxICMPReplyPacketCount 16 出力    pStatus_TxUDP0PacketCount 16 出力    pStatus_TxUDP1PacketCount 16 出力    pStatus_TxMulticastPacketCount 16 出力    pStatus_Phy 16 出力     IPコア用デバッグ信号 一般にユーザは利用しません．オープンにしてください．\n   ポート名 幅 方向 説明     pdebug 64 出力     Verilogインタンステンプレート インスタンス生成文 idelayctrl_wrapper#(.CLK_PERIOD(5))(.clk(clk200M), .reset(reset200M), .ready()); e7udpip_rgmii_artix7 u_e7udpip ( // GMII PHY  .GEPHY_RST_N(GEPHY_RST_N), .GEPHY_MAC_CLK(clk125M), .GEPHY_MAC_CLK90(clk125M_90), // TX out  .GEPHY_TD(GEPHY_TD), .GEPHY_TXEN_ER(GEPHY_TXEN_ER), .GEPHY_TCK(GEPHY_TCK), // RX in  .GEPHY_RD(GEPHY_RD), .GEPHY_RCK(GEPHY_RCK), .GEPHY_RXDV_ER(GEPHY_RXDV_ER), .GEPHY_MDC(GEPHY_MDC), .GEPHY_MDIO(GEPHY_MDIO), .GEPHY_INT_N(GEPHY_INT_N), // Asynchronous Reset  .Reset_n(~reset125M), // UPL interface  .pUPLGlobalClk(clk125M), // UDP tx input  .pUdp0Send_Data(pUdp0Send_Data), .pUdp0Send_Request(pUdp0Send_Request), .pUdp0Send_Ack(pUdp0Send_Ack), .pUdp0Send_Enable(pUdp0Send_Enable), .pUdp1Send_Data(pUdp1Send_Data), .pUdp1Send_Request(pUdp1Send_Request), .pUdp1Send_Ack(pUdp1Send_Ack), .pUdp1Send_Enable(pUdp1Send_Enable), // UDP rx output  .pUdp0Receive_Data(pUdp0Receive_Data), .pUdp0Receive_Request(pUdp0Receive_Request), .pUdp0Receive_Ack(pUdp0Receive_Ack), .pUdp0Receive_Enable(pUdp0Receive_Enable), .pUdp1Receive_Data(pUdp1Receive_Data), .pUdp1Receive_Request(pUdp1Receive_Request), .pUdp1Receive_Ack(pUdp1Receive_Ack), .pUdp1Receive_Enable(pUdp1Receive_Enable), // MII interface  .pMIIInput_Data(pMIIInput_Data), .pMIIInput_Request(pMIIInput_Request), .pMIIInput_Ack(pMIIInput_Ack), .pMIIInput_Enable(pMIIInput_Enable), .pMIIOutput_Data(pMIIOutput_Data), .pMIIOutput_Request(pMIIOutput_Request), .pMIIOutput_Ack(pMIIOutput_Ack), .pMIIOutput_Enable(pMIIOutput_Enable), // Setup  .pMyIpAddr(32\u0026#39;h0a000003), .pMyMacAddr(48\u0026#39;h001b1affffff), .pMyNetmask(32\u0026#39;hff000000), .pDefaultGateway(32\u0026#39;h0a0000fe), .pTargetIPAddr(32\u0026#39;h0a000001), .pMyUdpPort0(16\u0026#39;h4000), .pMyUdpPort1(16\u0026#39;h4001), .pPHYAddr(5\u0026#39;b00001), .pPHYMode(4\u0026#39;b1000), .pConfig_Core(8\u0026#39;b00000000), // Status  .pStatus_RxByteCount(), .pStatus_RxPacketCount(), .pStatus_RxErrorPacketCount(), .pStatus_RxDropPacketCount(), .pStatus_RxARPRequestPacketCount(), .pStatus_RxARPReplyPacketCount(), .pStatus_RxICMPPacketCount(), .pStatus_RxUDP0PacketCount(), .pStatus_RxUDP1PacketCount(), .pStatus_RxIPErrorPacketCount(), .pStatus_RxUDPErrorPacketCount(), .pStatus_TxByteCount(), .pStatus_TxPacketCount(), .pStatus_TxARPRequestPacketCount(), .pStatus_TxARPReplyPacketCount(), .pStatus_TxICMPReplyPacketCount(), .pStatus_TxUDP0PacketCount(), .pStatus_TxUDP1PacketCount(), .pStatus_TxMulticastPacketCount(), .pStatus_Phy(status_phy), .pdebug() ); Verilog用スタブ 次のコードは，edifファイルを組み込むためのスタブファイルです．入出力ポートの向きやサイズの確認にご利用ください．\nmodule e7udpip_rgmii_artix7( output wire GEPHY_RST_N, input wire GEPHY_MAC_CLK, input wire GEPHY_MAC_CLK90, // TX out  output wire [3:0] GEPHY_TD, output wire GEPHY_TXEN_ER, output wire GEPHY_TCK, // RX in  input wire [3:0] GEPHY_RD, input wire GEPHY_RCK, input wire GEPHY_RXDV_ER, //Management I/F  output wire GEPHY_MDC, inout wire GEPHY_MDIO, input wire GEPHY_INT_N, // Asynchronous Reset  input wire Reset_n, // UPL interface  input wire pUPLGlobalClk, // UDP tx input  input wire [31:0] pUdp0Send_Data, input wire pUdp0Send_Request, output wire pUdp0Send_Ack, input wire pUdp0Send_Enable, input wire [31:0] pUdp1Send_Data, input wire pUdp1Send_Request, output wire pUdp1Send_Ack, input wire pUdp1Send_Enable, // UDP rx output  output wire [31:0] pUdp0Receive_Data, output wire pUdp0Receive_Request, input wire pUdp0Receive_Ack, output wire pUdp0Receive_Enable, output wire [31:0] pUdp1Receive_Data, output wire pUdp1Receive_Request, input wire pUdp1Receive_Ack, output wire pUdp1Receive_Enable, // MII interface  input wire [31:0] pMIIInput_Data, input wire pMIIInput_Request, output wire pMIIInput_Ack, input wire pMIIInput_Enable, output wire [31:0] pMIIOutput_Data, output wire pMIIOutput_Request, input wire pMIIOutput_Ack, output wire pMIIOutput_Enable, // Setup  input wire [31:0] pMyIpAddr, input wire [47:0] pMyMacAddr, input wire [31:0] pMyNetmask, input wire [31:0] pDefaultGateway, input wire [31:0] pTargetIPAddr, input wire [15:0] pMyUdpPort0, input wire [15:0] pMyUdpPort1, input wire [4:0] pPHYAddr, input wire [3:0] pPHYMode, input wire [31:0] pConfig_Core, //Status  output wire [31:0] pStatus_RxByteCount, output wire [31:0] pStatus_RxPacketCount, output wire [15:0] pStatus_RxErrorPacketCount, output wire [15:0] pStatus_RxDropPacketCount, output wire [15:0] pStatus_RxARPRequestPacketCount, output wire [15:0] pStatus_RxARPReplyPacketCount, output wire [15:0] pStatus_RxICMPPacketCount, output wire [15:0] pStatus_RxUDP0PacketCount, output wire [15:0] pStatus_RxUDP1PacketCount, output wire [15:0] pStatus_RxIPErrorPacketCount, output wire [15:0] pStatus_RxUDPErrorPacketCount, output wire [31:0] pStatus_TxByteCount, output wire [31:0] pStatus_TxPacketCount, output wire [15:0] pStatus_TxARPRequestPacketCount, output wire [15:0] pStatus_TxARPReplyPacketCount, output wire [15:0] pStatus_TxICMPReplyPacketCount, output wire [15:0] pStatus_TxUDP0PacketCount, output wire [15:0] pStatus_TxUDP1PacketCount, output wire [15:0] pStatus_TxMulticastPacketCount, output wire [15:0] pStatus_Phy, output wire [63:0] pdebug ); endmodule VHDLインタンステンプレート コンポーネント宣言 component e7udpip_rgmii_artix7 port ( GEPHY_RST_N : out std_logic; GEPHY_MAC_CLK : in std_logic; GEPHY_MAC_CLK90 : in std_logic; -- TX out GEPHY_TD : out std_logic_vector(3 downto 0); GEPHY_TXEN_ER : out std_logic; GEPHY_TCK : out std_logic; -- RX in GEPHY_RD : in std_logic_vector(3 downto 0); GEPHY_RCK : in std_logic; GEPHY_RXDV_ER : in std_logic; --Management I/F GEPHY_MDC : out std_logic; GEPHY_MDIO : inout std_logic; GEPHY_INT_N : in std_logic; -- Asynchronous Reset Reset_n : in std_logic; -- UPL interface pUPLGlobalClk : in std_logic; -- UDP tx input pUdp0Send_Data : in std_logic_vector(31 downto 0); pUdp0Send_Request : in std_logic; pUdp0Send_Ack : out std_logic; pUdp0Send_Enable : in std_logic; pUdp1Send_Data : in std_logic_vector(31 downto 0); pUdp1Send_Request : in std_logic; pUdp1Send_Ack : out std_logic; pUdp1Send_Enable : in std_logic; -- UDP rx output pUdp0Receive_Data : out std_logic_vector(31 downto 0); pUdp0Receive_Request : out std_logic; pUdp0Receive_Ack : in std_logic; pUdp0Receive_Enable : out std_lgoic; pUdp1Receive_Data : out std_logic_vector(31 downto 0); pUdp1Receive_Request : out std_logic; pUdp1Receive_Ack : in std_logic; pUdp1Receive_Enable : out std_lgoic; -- MII interface pMIIInput_Data : in std_logic_vector(31 downto 0); pMIIInput_Request : in std_logic; pMIIInput_Ack : out std_logic; pMIIInput_Enable : in std_logic; pMIIOutput_Data : out std_logic_vector(31 downto 0); pMIIOutput_Request : out std_logic; pMIIOutput_Ack : in std_logic; pMIIOutput_Enable : out std_logic; -- Setup pMyIpAddr : in std_logic_vector(31 downto 0); pMyMacAddr : in std_logic_vector(47 downto 0); pMyNetmask : in std_logic_vector(31 downto 0); pDefaultGateway : in std_logic_vector(31 downto 0); pTargetIPAddr : in std_logic_vector(31 downto 0); pMyUdpPort0 : in std_logic_vector(15 downto 0); pMyUdpPort1 : in std_logic_vector(15 downto 0); pPHYAddr : in std_logic_vector(4 downto 0); pPHYMode : in std_logic_vector(3 downto 0); pConfig_Core : in std_logic_vector(31 downto 0); -- Status pStatus_RxByteCount : out std_logic_vector(31 downto 0); pStatus_RxPacketCount : out std_logic_vector(31 downto 0); pStatus_RxErrorPacketCount : out std_logic_vector(15 downto 0); pStatus_RxDropPacketCount : out std_logic_vector(15 downto 0); pStatus_RxARPRequestPacketCount : out std_logic_vector(15 downto 0); pStatus_RxARPReplyPacketCount : out std_logic_vector(15 downto 0); pStatus_RxICMPPacketCount : out std_logic_vector(15 downto 0); pStatus_RxUDP0PacketCount : out std_logic_vector(15 downto 0); pStatus_RxUDP1PacketCount : out std_logic_vector(15 downto 0); pStatus_RxIPErrorPacketCount : out std_logic_vector(15 downto 0); pStatus_RxUDPErrorPacketCount : out std_logic_vector(15 downto 0); pStatus_TxByteCount : out std_logic_vector(31 downto 0); pStatus_TxPacketCount : out std_logic_vector(31 downto 0); pStatus_TxARPRequestPacketCount : out std_logic_vector(15 downto 0); pStatus_TxARPReplyPacketCount : out std_logic_vector(15 downto 0); pStatus_TxICMPReplyPacketCount : out std_logic_vector(15 downto 0); pStatus_TxUDP0PacketCount : out std_logic_vector(15 downto 0); pStatus_TxUDP1PacketCount : out std_logic_vector(15 downto 0); pStatus_TxMulticastPacketCount : out std_logic_vector(15 downto 0); pStatus_Phy : out std_logic_vector(15 downto 0); pdebug : out std_logic_vector(63 downto 0) ); end component e7udpip_rgmii_artix7; インスタンス生成の例 idelayctrl_wrapper_u : idelayctrl_wrapper generic map(CLK_PERIOD =\u0026gt; 5) port map(clk =\u0026gt; clk200M, reset=\u0026gt;reset200M, ready=\u0026gt;open); u_e7udpip : e7udpip_rgmii_artix7 port map( -- GMII PHY GEPHY_RST_N =\u0026gt; open, GEPHY_MAC_CLK =\u0026gt; clk125M, GEPHY_MAC_CLK90 =\u0026gt; clk125M_90, -- TX out GEPHY_TD =\u0026gt; GEPHY_TD, GEPHY_TXEN_ER =\u0026gt; GEPHY_TXEN_ER, GEPHY_TCK =\u0026gt; GEPHY_TCK, -- RX in GEPHY_RD =\u0026gt; GEPHY_RD, GEPHY_RCK =\u0026gt; GEPHY_RCK, GEPHY_RXDV_ER =\u0026gt; GEPHY_RXDV_ER, GEPHY_MDC =\u0026gt; GEPHY_MDC, GEPHY_MDIO =\u0026gt; GEPHY_MDIO, GEPHY_INT_N =\u0026gt; GEPHY_INT_N, -- Asynchronous Reset Reset_n =\u0026gt; not reset125M, -- UPL interface pUPLGlobalClk =\u0026gt; clk125M, -- UDP tx input pUdp0Send_Data =\u0026gt; pUdp0Send_Data, pUdp0Send_Request =\u0026gt; pUdp0Send_Request, pUdp0Send_Ack =\u0026gt; pUdp0Send_Ack, pUdp0Send_Enable =\u0026gt; pUdp0Send_Enable, pUdp1Send_Data =\u0026gt; pUdp1Send_Data, pUdp1Send_Request =\u0026gt; pUdp1Send_Request, pUdp1Send_Ack =\u0026gt; pUdp1Send_Ack, pUdp1Send_Enable =\u0026gt; pUdp1Send_Enable, -- UDP rx output pUdp0Receive_Data =\u0026gt; pUdp0Receive_Data, pUdp0Receive_Request =\u0026gt; pUdp0Receive_Request, pUdp0Receive_Ack =\u0026gt; pUdp0Receive_Ack, pUdp0Receive_Enable =\u0026gt; pUdp0Receive_Enable, pUdp1Receive_Data =\u0026gt; pUdp1Receive_Data, pUdp1Receive_Request =\u0026gt; pUdp1Receive_Request, pUdp1Receive_Ack =\u0026gt; pUdp1Receive_Ack, pUdp1Receive_Enable =\u0026gt; pUdp1Receive_Enable, -- MII interface pMIIInput_Data =\u0026gt; pMIIInput_Data, pMIIInput_Request =\u0026gt; pMIIInput_Request, pMIIInput_Ack =\u0026gt; pMIIInput_Ack, pMIIInput_Enable =\u0026gt; pMIIInput_Enable, pMIIOutput_Data =\u0026gt; pMIIOutput_Data, pMIIOutput_Request =\u0026gt; pMIIOutput_Request, pMIIOutput_Ack =\u0026gt; pMIIOutput_Ack, pMIIOutput_Enable =\u0026gt; pMIIOutput_Enable, -- Setup pMyIpAddr =\u0026gt; X\u0026#34;0a000003\u0026#34;, pMyMacAddr =\u0026gt; X\u0026#34;001b1affffff\u0026#34;, pMyNetmask =\u0026gt; X\u0026#34;ff000000\u0026#34;, pDefaultGateway =\u0026gt; X\u0026#34;0a0000fe\u0026#34;, pTargetIPAddr =\u0026gt; X\u0026#34;0a000001\u0026#34;, pMyUdpPort0 =\u0026gt; X\u0026#34;4000\u0026#34;, pMyUdpPort1 =\u0026gt; X\u0026#34;4001\u0026#34;, pPHYAddr =\u0026gt; \u0026#34;00001\u0026#34;, pPHYMode =\u0026gt; \u0026#34;1000\u0026#34;, pConfig_Core =\u0026gt; \u0026#34;00000000\u0026#34;, -- Status pStatus_RxByteCount =\u0026gt; open, pStatus_RxPacketCount =\u0026gt; open, pStatus_RxErrorPacketCount =\u0026gt; open, pStatus_RxDropPacketCount =\u0026gt; open, pStatus_RxARPRequestPacketCount =\u0026gt; open, pStatus_RxARPReplyPacketCount =\u0026gt; open, pStatus_RxICMPPacketCount =\u0026gt; open, pStatus_RxUDP0PacketCount =\u0026gt; open, pStatus_RxUDP1PacketCount =\u0026gt; open, pStatus_RxIPErrorPacketCount =\u0026gt; open, pStatus_RxUDPErrorPacketCount =\u0026gt; open, pStatus_TxByteCount =\u0026gt; open, pStatus_TxPacketCount =\u0026gt; open, pStatus_TxARPRequestPacketCount =\u0026gt; open, pStatus_TxARPReplyPacketCount =\u0026gt; open, pStatus_TxICMPReplyPacketCount =\u0026gt; open, pStatus_TxUDP0PacketCount =\u0026gt; open, pStatus_TxUDP1PacketCount =\u0026gt; open, pStatus_TxMulticastPacketCount =\u0026gt; open, pStatus_Phy =\u0026gt; status_phy, pdebug =\u0026gt; open ); "});index.add({'id':5,'href':'/exstickge_guide/docs/udpip/sendrecv_packet/','title':"パケットを送受信してみる",'content':"パケットを送受信してみる e7UDP/IP IPコアを使ったパケット送受信方法を説明します．\nループバック exStickGEで受信したパケットをそのまま送信するループバックしてみます．これは単に，IPコアの出力UPLを入力UPLに接続するだけで実現できます．\nソースコードは，exstickge_samples/exStickGE_udpip_loopback/sources/top.v をご覧ください．\nassign pUdp0Send_Data = pUdp0Receive_Data; assign pUdp0Send_Request = pUdp0Receive_Request; assign pUdp0Receive_Ack = pUdp0Send_Ack; assign pUdp0Send_Enable = pUdp0Receive_Enable; assign pUdp1Send_Data = pUdp1Receive_Data; assign pUdp1Send_Request = pUdp1Receive_Request; assign pUdp1Receive_Ack = pUdp1Send_Ack; assign pUdp1Send_Enable = pUdp1Receive_Enable; の部分がループバックに相当します．\nUDP/IPパケットを送信する UDP/IPパケットを送信するには，UDP/IP IPコア概要で紹介した，次のフォーマットに従ったデータ列をUPLから入力します．\n   # 内容     0 送信送り元IPアドレス(exStickGEのIPアドレス)   1 送信先IPアドレス   2 送信元ポート番号，送信先ポート番号,   3 データバイト数   4〜 データ    適当なステートマシンで，UPLフォーマットに従ったデータ列を生成することで任意のUDPパケットをexStickGEから送出できます．\nUDP/IPパケットを受信する 受信したUDP/IPパケットをユーザロジックで利用するには，UDP/IP IPコア概要で紹介した，次のフォーマットのデータ列をUPLから受け取ります．\n   # 内容     0 送信送り元IPアドレス(exStickGEのIPアドレス)   1 送信先IPアドレス   2 送信元ポート番号，送信先ポート番号,   3 データバイト数   4〜 データ    適当なステートマシンで，UPLフォーマットに従ったデータ列を解析してデータ部分を取り出すことで，exStickGEが受信したデータをユーザロジックで利用できます．\n"});index.add({'id':6,'href':'/exstickge_guide/docs/','title':"Docs",'content':""});index.add({'id':7,'href':'/exstickge_guide/','title':"Top",'content':"exStickGE Quick Guide exStickGEについて  ボード概要  セットアップ  インストール exStickGEでLチカ サンプルのビルドと実行  付属UDP/IP IPコアの利用  UDP/IP IPコア概要 パケットの送受信  サンプル事例  exStickGE_udpip_loopback  exStickGEに到達したUDPパケットを折り返すだけのサンプルです．コアのインスタンス生成方法の確認に．   exStickGE_hdmi2udp  ビジョン基板上のHDMIから入力された画像をUDPパケットで出力するサンプルです．   exStickGE_dramrw  UDPパケットでexStickGEに搭載されたDRAMを読み書きするサンプルです．DRAMを利用する場合のエントリポイントに．   exStickGE_dram_hdmiout  DRAMに書き込んだ画像イメージをビジョン基板上のHDMIから出力するサンプルです 詳細は，exStickGEでHDMI表示をしてみたをご覧ください．   exStickGE_hdmi2dram2udp  ビジョン基板上のHDMIから入力された画像をDRAMに保存した後でUDPで出力するサンプルです 詳細は，exStickGEでHDMIの画像を取得してみたをご覧ください．   exStickGE_imageprocessing  ビジョン基板上のHDMIから入力された画像をDRAMに保存し，フィルタ処理を適用してUDPで出力するサンプルです 詳細は，exStickGEで画像にフィルタをかけてみたをご覧ください．    LICENSE  This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License\n"});index.add({'id':8,'href':'/exstickge_guide/categories/','title':"Categories",'content':""});index.add({'id':9,'href':'/exstickge_guide/tags/','title':"Tags",'content':""});})();